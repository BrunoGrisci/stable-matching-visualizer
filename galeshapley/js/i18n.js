(function () {
  const messages = {
    en: {
      app_title: 'Gale-Shapley Stable Matching Visualizer',
      app_subtitle: 'Explore step-by-step proposals, engagements, and stability properties.',

      help_open: 'Open quick help',
      help_title: 'How to use this tool',
      help_intro: 'This visualizer executes Gale-Shapley step by step and explains why the matching is stable.',
      help_li_1: 'Choose a preset or build your own instance using the editable tables.',
      help_li_2: 'Pick the proposer side, then use Run step, Auto run, or Run full.',
      help_li_3: 'Inspect highlighted preference tables and the bipartite graph animation.',
      help_li_4: 'Use the Curves tab to compare random, inverse, easy, and worst-case families.',
      close_btn: 'Close',

      toggle_controls_hide: 'Collapse controls panel',
      toggle_controls_show: 'Expand controls panel',
      toggle_code_hide: 'Collapse algorithm panel',
      toggle_code_show: 'Expand algorithm panel',

      controls_title: 'Controls',
      variant_label: 'Scenario',
      variant_classic: 'Stable Marriage',
      variant_good_bad: 'Good and Bad Categories',
      variant_forbidden: 'Forbidden Pairs',
      variant_capacity: 'Resident Matching',
      scenario_note_classic: 'Stable Marriage: one-to-one stable matching between two groups with strict preferences.',
      scenario_note_good_bad: 'Participants are split into good/bad categories and preferences prioritize good first.',
      scenario_note_forbidden: 'Certain proposer-receiver pairs are disallowed via an external forbidden set F; proposals skip those pairs.',
      scenario_note_capacity: 'Resident Matching: proposer side has capacities and may hold multiple engagements simultaneously.',

      preset_label: 'Instance preset',
      preset_hpl: 'HPL/SPL Demo',
      preset_worst_case_demo: 'Worst case',
      preset_random: 'Random',
      preset_inverse: 'Inverse',
      preset_easy: 'Easy',
      preset_note_hpl: 'HPL/SPL example from the Princeton Gale-Shapley demo.',
      preset_note_worst_case: 'Generated worst-case family instance for the selected n. In Good/Bad scenario, who is good/bad is randomized, with good candidates listed before bad ones.',
      preset_note_random: 'Random preferences on both sides. In Good/Bad scenario, who is good/bad is randomized, and all good candidates appear before bad ones.',
      preset_note_inverse: 'Inverse pattern: all proposers share the same order and receivers use reversed proposer order. In Good/Bad scenario, who is good/bad is randomized, with good candidates listed before bad ones.',
      preset_note_easy: 'Easy pattern. In Good/Bad scenario, who is good/bad is randomized, and preference lists keep all good candidates before bad ones.',

      pairs_label: 'Number of pairs (n)',
      good_count_label: 'Good count (k)',
      resident_count_label: 'Number of residents',
      positions_count_label: 'Total number of positions',
      hospital_count_label: 'Number of hospitals',
      hospital_pos_range_label: 'Hospital positions range',
      hospital_pos_min_label: 'Hospital positions min',
      hospital_pos_max_label: 'Hospital positions max',
      resident_apps_range_label: 'Resident applications range',
      resident_apps_min_label: 'Resident applications min',
      resident_apps_max_label: 'Resident applications max',
      range_min: 'Min',
      range_max: 'Max',
      proposer_label: 'Proposer side',
      proposer_generic: '{group} propose',
      proposer_men: 'Men propose',
      proposer_women: 'Women propose',
      group_left_label: 'Left group name',
      group_right_label: 'Right group name',

      load_preset_btn: 'Load instance',
      reset_btn: 'Reset run',
      advanced_summary: 'Variant parameters',
      forbidden_label: 'Forbidden pairs count (0 to n^2)',
      capacity_label: 'Capacities (proposer:cap, comma separated)',
      speed_label: 'Auto speed',
      run_step_btn: 'Run step',
      auto_run_btn: 'Auto run',
      auto_pause_btn: 'Pause',
      run_full_btn: 'Run full',
      csv_label: 'Import instance (.csv)',

      counter_proposals: 'Proposals',
      counter_engaged: 'Engaged pairs',
      counter_single_men: 'Single men',
      counter_single_women: 'Single women',
      counter_single_generic: 'Single {group}',

      tab_sim: 'Simulation',
      tab_curves: 'Curves',
      men_pref_title: 'Men preferences',
      women_pref_title: 'Women preferences',
      pref_title_generic: '{group} preferences',
      graph_title: 'Bipartite graph',
      graph_mode_full: 'Detailed graph',
      graph_mode_large: 'Large-n compact graph',
      graph_exhausted: 'proposed to everyone',
      insights_title: 'Correctness insights',
      code_title: 'Algorithm code',
      ds_title: 'Data structures',
      ds_exhausted: 'exhausted proposers',
      ds_receiver: 'receiver',
      ds_proposer: 'proposer',
      ds_top_rank: 'top rank map',
      ds_forbidden: 'forbidden pairs',
      ds_caps: 'capacities',
      log_title: 'Step log',

      editor_men_title: 'Editable men table',
      editor_women_title: 'Editable women table',
      editor_title_generic: 'Editable {group} table',
      add_row_btn: 'Add row',
      editor_col_name: 'Name',
      editor_col_prefs: 'Preferences (comma separated)',
      editor_col_cap: 'Cap',
      editor_col_cat: 'Category',
      editor_col_del: 'Del',
      apply_tables_btn: 'Apply editable tables',
      export_csv_btn: 'Export CSV',

      table_partner: 'Partner(s)',
      table_prefs: 'Preference list',

      curve_start: 'n start',
      curve_end: 'n end',
      curve_step: 'n step',
      curve_repeats: 'Repetitions per n (Random only)',
      curve_xmax: 'X max',
      curve_yzoom: 'Y zoom',
      curve_run_btn: 'Run curves',
      curve_stop_btn: 'Stop',
      curve_chart_title: 'Proposal curves by instance size',
      curve_table_title: 'Average proposals table',
      curve_col_n: 'n',
      curve_col_random: 'Random',
      curve_col_inverse: 'Inverse',
      curve_col_easy: 'Easy',
      curve_col_worst_case: 'Worst case',
      curve_col_linear: '~ n',
      curve_col_half: '~ n(n+1)/2',
      curve_col_square: '~ n^2',
      curve_axis_x: 'Number of pairs (n)',
      curve_axis_y: 'Proposals',

      references_title: 'References',
      ref_main: 'Main references',
      see_more_algorithms: 'See more algorithms',
      references_thanks_prefix: 'Thanks to Dr. Luciana Salete Buriol',
      references_thanks_suffix: 'who first taught me about this algorithm.',
      footer_repo: 'Project repository:',
      footer_license: 'MIT License',
      footer_references: 'References',
      footer_ai: 'Developed with assistance from GPT-5.3-Codex.',
      footer_thanks_prefix: 'Thanks to Dr. Luciana Salete Buriol',
      footer_thanks_suffix: 'who first taught me about this algorithm.',

      status_loaded: 'Instance loaded. Ready to run.',
      status_reset: 'Execution reset to initial state.',
      status_running: 'Auto run is active.',
      status_paused: 'Auto run paused.',
      status_finished: 'Execution finished.',
      status_full: 'Execution jumped to final state (Run full).',
      status_invalid: 'Invalid instance. Please check names and preference lists.',
      status_csv_loaded: 'CSV instance imported successfully.',
      status_csv_error: 'Could not parse CSV instance.',
      status_table_applied: 'Editable tables applied.',
      status_curve_running: 'Running curve benchmark...',
      status_curve_done: 'Curve benchmark completed.',
      status_curve_stopped: 'Curve benchmark stopped.',
      status_export_done: 'CSV exported.',
      status_became_single: 'became single',

      step_initial: 'All participants start free.',
      step_choose: '{proposer} is free and chooses {receiver}.',
      step_exhausted: '{proposer} has already proposed to everyone, skip (no match possible).',
      step_accept_free: '{receiver} is free (or has free slot) and accepts {proposer}.',
      step_reject: '{receiver} rejects {proposer} and keeps current engagement(s).',
      step_replace: '{receiver} prefers {proposer}, accepts proposal, and releases {displaced}.',
      step_finished: 'No free proposer with remaining acceptable choices. Algorithm terminates.',
      note_propose: '{proposer} proposes to {receiver}.',
      note_accept: '{receiver} accepts.',
      note_reject: '{receiver} rejects.',
      note_renounces: '(and renounces {displaced})',
      note_prefers: '(since prefers {displaced})',

      insight_perfect_title: 'Perfect matching',
      insight_stable_title: 'No unstable pairs',
      insight_terminates_title: 'Termination bound',
      insight_optimal_title: 'Proposer-optimal / receiver-pessimal',
      insight_good_bad_title: 'Every good man matched to a good woman (current matching)',
      insight_true: 'Yes',
      insight_false: 'No',
      insight_pending: 'Run until completion to evaluate.',
      insight_termination_value: '{used} / {bound} proposals',
      insight_optimal_current: 'Holds for the computed matching in this one-to-one setting.',
      insight_optimal_current_many_to_one: 'Holds for the computed matching in this many-to-one setting.',
      insight_optimal_not_applicable: 'Evaluated in one-to-one settings without forbidden pairs, and in resident matching.',
      insight_good_bad_current: 'Holds for the computed matching.',
      insight_good_bad_not_applicable: 'Categories missing or incomplete.',

      side_men: 'Men',
      side_women: 'Women',
      side_hospitals: 'Hospitals',
      side_residents: 'Residents',
      partner_none: '-',
      code_comment_exhausted_all: 'proposed to everyone',
      code_comment_exhausted_allowed: 'proposed to every allowed receiver (not in F)',
      code_comment_prefs_exclude_f: 'p_prefs contains only pairs (p, r) with (p, r) not in F',
      code_comment_engaged_one: 'receiver -> proposer',
      code_comment_engaged_many: 'receiver -> proposers',
      code_comment_worst_current: 'worst current proposer held by receiver',

      code_1: '1  from collections import deque',
      code_2: '2  w_rank = {w: {m: i for i, m in enumerate(pref)} for w, pref in w_prefs.items()}',
      code_3: '3  free_men = deque(m_prefs.keys())',
      code_4: '4  next_idx = {m: 0 for m in m_prefs}',
      code_5: '5  engaged_to = {}  # woman -> man',
      code_6: '6  while free_men:',
      code_7: '7      m = free_men.popleft()',
      code_8: '8      if next_idx[m] >= len(m_prefs[m]): continue  # proposed to everyone',
      code_9: '9      w = m_prefs[m][next_idx[m]]',
      code_10: '10     next_idx[m] += 1',
      code_11: '11     if w not in engaged_to:',
      code_12: '12         engaged_to[w] = m',
      code_13: '13     else:',
      code_14: "14         m_prime = engaged_to[w]",
      code_15: '15         if w_rank[w][m_prime] < w_rank[w][m]: free_men.append(m)',
      code_16: '16         else:',
      code_17: '17             engaged_to[w] = m; free_men.append(m_prime)',
      code_18: '18 return {(m, w) for w, m in engaged_to.items()}',

      legend_rank: 'rank',
      legend_engaged: 'engaged edge',
      legend_active: 'current proposal',
      legend_regular: 'preference edge',

      curve_progress: 'n={n} ({done}/{total})',
      curve_idle: 'Configure interval and run to generate curves.',
      curve_empty: 'No data yet.',

      category_good: 'good',
      category_bad: 'bad'
    },

    pt: {
      app_title: 'Visualizador de Emparelhamento Estável Gale-Shapley',
      app_subtitle: 'Explore propostas, noivados e propriedades de estabilidade passo a passo.',

      help_open: 'Abrir ajuda rápida',
      help_title: 'Como usar a ferramenta',
      help_intro: 'Este visualizador executa Gale-Shapley passo a passo e explica por que o emparelhamento é estável.',
      help_li_1: 'Escolha um preset ou monte sua própria instância nas tabelas editáveis.',
      help_li_2: 'Selecione quem propõe e use Executar passo, Auto executar ou Executar completo.',
      help_li_3: 'Observe as tabelas de preferência destacadas e a animação no grafo bipartido.',
      help_li_4: 'Use a aba Curvas para comparar famílias aleatória, inversa, fácil e pior caso.',
      close_btn: 'Fechar',

      toggle_controls_hide: 'Recolher painel de controles',
      toggle_controls_show: 'Expandir painel de controles',
      toggle_code_hide: 'Recolher painel do algoritmo',
      toggle_code_show: 'Expandir painel do algoritmo',

      controls_title: 'Controles',
      variant_label: 'Cenário',
      variant_classic: 'Casamento estável',
      variant_good_bad: 'Categorias boas e ruins',
      variant_forbidden: 'Pares proibidos',
      variant_capacity: 'Pareamento de residentes',
      scenario_note_classic: 'Casamento estável: emparelhamento um-para-um entre dois grupos com preferências estritas.',
      scenario_note_good_bad: 'Participantes são divididos em categorias bom/ruim e preferências priorizam os bons.',
      scenario_note_forbidden: 'Certos pares proponente-receptor são proibidos por um conjunto externo F; propostas ignoram esses pares.',
      scenario_note_capacity: 'Pareamento de residentes: o lado proponente possui capacidades e pode manter múltiplos noivados simultaneamente.',

      preset_label: 'Preset de instância',
      preset_hpl: 'Demo HPL/SPL',
      preset_worst_case_demo: 'Pior caso',
      preset_random: 'Aleatória',
      preset_inverse: 'Inversa',
      preset_easy: 'Fácil',
      preset_note_hpl: 'Exemplo HPL/SPL da demonstração de Gale-Shapley de Princeton.',
      preset_note_worst_case: 'Instância gerada da família de pior caso para o n selecionado. No cenário Bom/Ruim, quem é bom/ruim é sorteado, com bons antes de ruins.',
      preset_note_random: 'Preferências aleatórias em ambos os lados. No cenário Bom/Ruim, quem é bom/ruim é sorteado, e todos os candidatos bons aparecem antes dos ruins.',
      preset_note_inverse: 'Padrão inverso: todos os proponentes têm a mesma ordem e receptores usam ordem inversa dos proponentes. No cenário Bom/Ruim, quem é bom/ruim é sorteado, com bons antes de ruins.',
      preset_note_easy: 'Padrão fácil. No cenário Bom/Ruim, quem é bom/ruim é sorteado, e as listas mantêm todos os candidatos bons antes dos ruins.',

      pairs_label: 'Número de pares (n)',
      good_count_label: 'Quantidade de bons (k)',
      resident_count_label: 'Número de residentes',
      positions_count_label: 'Número total de vagas',
      hospital_count_label: 'Número de hospitais',
      hospital_pos_range_label: 'Faixa de vagas por hospital',
      hospital_pos_min_label: 'Mínimo de vagas por hospital',
      hospital_pos_max_label: 'Máximo de vagas por hospital',
      resident_apps_range_label: 'Faixa de candidaturas por residente',
      resident_apps_min_label: 'Mínimo de candidaturas por residente',
      resident_apps_max_label: 'Máximo de candidaturas por residente',
      range_min: 'Mín',
      range_max: 'Máx',
      proposer_label: 'Lado proponente',
      proposer_generic: '{group} propõem',
      proposer_men: 'Homens propõem',
      proposer_women: 'Mulheres propõem',
      group_left_label: 'Nome do grupo da esquerda',
      group_right_label: 'Nome do grupo da direita',

      load_preset_btn: 'Carregar instância',
      reset_btn: 'Reiniciar execução',
      advanced_summary: 'Parâmetros da variação',
      forbidden_label: 'Quantidade de pares proibidos (0 a n^2)',
      capacity_label: 'Capacidades (proponente:cap, separados por vírgula)',
      speed_label: 'Velocidade do auto',
      run_step_btn: 'Executar passo',
      auto_run_btn: 'Auto executar',
      auto_pause_btn: 'Pausar',
      run_full_btn: 'Executar completo',
      csv_label: 'Importar instância (.csv)',

      counter_proposals: 'Propostas',
      counter_engaged: 'Pares noivos',
      counter_single_men: 'Homens solteiros',
      counter_single_women: 'Mulheres solteiras',
      counter_single_generic: '{group} solteiros',

      tab_sim: 'Simulação',
      tab_curves: 'Curvas',
      men_pref_title: 'Preferências dos homens',
      women_pref_title: 'Preferências das mulheres',
      pref_title_generic: 'Preferências de {group}',
      graph_title: 'Grafo bipartido',
      graph_mode_full: 'Grafo detalhado',
      graph_mode_large: 'Grafo compacto para n grande',
      graph_exhausted: 'propôs para todos',
      insights_title: 'Insights de corretude',
      code_title: 'Código do algoritmo',
      ds_title: 'Estruturas de dados',
      ds_exhausted: 'proponentes esgotados',
      ds_receiver: 'receptor',
      ds_proposer: 'proponente',
      ds_top_rank: 'mapa de ranking',
      ds_forbidden: 'pares proibidos',
      ds_caps: 'capacidades',
      log_title: 'Log de passos',

      editor_men_title: 'Tabela editável de homens',
      editor_women_title: 'Tabela editável de mulheres',
      editor_title_generic: 'Tabela editável de {group}',
      add_row_btn: 'Adicionar linha',
      editor_col_name: 'Nome',
      editor_col_prefs: 'Preferências (separadas por vírgula)',
      editor_col_cap: 'Cap',
      editor_col_cat: 'Categoria',
      editor_col_del: 'Del',
      apply_tables_btn: 'Aplicar tabelas editáveis',
      export_csv_btn: 'Exportar CSV',

      table_partner: 'Parceiro(s)',
      table_prefs: 'Lista de preferências',

      curve_start: 'n inicial',
      curve_end: 'n final',
      curve_step: 'passo de n',
      curve_repeats: 'Repetições por n (apenas aleatória)',
      curve_xmax: 'X máximo',
      curve_yzoom: 'Zoom em Y',
      curve_run_btn: 'Executar curvas',
      curve_stop_btn: 'Parar',
      curve_chart_title: 'Curvas de propostas por tamanho da instância',
      curve_table_title: 'Tabela de médias de propostas',
      curve_col_n: 'n',
      curve_col_random: 'Aleatória',
      curve_col_inverse: 'Inversa',
      curve_col_easy: 'Fácil',
      curve_col_worst_case: 'Pior caso',
      curve_col_linear: '~ n',
      curve_col_half: '~ n(n+1)/2',
      curve_col_square: '~ n^2',
      curve_axis_x: 'Número de pares (n)',
      curve_axis_y: 'Propostas',

      references_title: 'Referências',
      ref_main: 'Referências principais',
      see_more_algorithms: 'Veja mais algoritmos',
      references_thanks_prefix: 'Agradecimentos à Dra. Luciana Salete Buriol',
      references_thanks_suffix: 'que primeiro me ensinou sobre este algoritmo.',
      footer_repo: 'Repositório do projeto:',
      footer_license: 'Licença MIT',
      footer_references: 'Referências',
      footer_ai: 'Desenvolvido com assistência do GPT-5.3-Codex.',
      footer_thanks_prefix: 'Agradecimentos à Dra. Luciana Salete Buriol',
      footer_thanks_suffix: 'que primeiro me ensinou sobre este algoritmo.',

      status_loaded: 'Instância carregada. Pronto para executar.',
      status_reset: 'Execução reiniciada para o estado inicial.',
      status_running: 'Auto execução ativa.',
      status_paused: 'Auto execução pausada.',
      status_finished: 'Execução finalizada.',
      status_full: 'Execução avançou direto para o estado final (Executar completo).',
      status_invalid: 'Instância inválida. Verifique nomes e listas de preferência.',
      status_csv_loaded: 'Instância CSV importada com sucesso.',
      status_csv_error: 'Não foi possível interpretar a instância CSV.',
      status_table_applied: 'Tabelas editáveis aplicadas.',
      status_curve_running: 'Executando benchmark das curvas...',
      status_curve_done: 'Benchmark das curvas concluído.',
      status_curve_stopped: 'Benchmark das curvas interrompido.',
      status_export_done: 'CSV exportado.',
      status_became_single: 'ficou solteiro',

      step_initial: 'Todos os participantes iniciam livres.',
      step_choose: '{proposer} está livre e escolhe {receiver}.',
      step_exhausted: '{proposer} já propôs para todos, pular (nenhum par possível).',
      step_accept_free: '{receiver} está livre (ou possui vaga livre) e aceita {proposer}.',
      step_reject: '{receiver} rejeita {proposer} e mantém o(s) noivado(s) atual(is).',
      step_replace: '{receiver} prefere {proposer}, aceita a proposta e libera {displaced}.',
      step_finished: 'Não existe proponente livre com opções aceitáveis restantes. Algoritmo termina.',
      note_propose: '{proposer} propõe para {receiver}.',
      note_accept: '{receiver} aceita.',
      note_reject: '{receiver} rejeita.',
      note_renounces: '(e desfaz noivado com {displaced})',
      note_prefers: '(pois prefere {displaced})',

      insight_perfect_title: 'Emparelhamento perfeito',
      insight_stable_title: 'Sem pares instáveis',
      insight_terminates_title: 'Limite de terminação',
      insight_optimal_title: 'Ótimo para proponentes / péssimo para receptores',
      insight_good_bad_title: 'Todo homem bom casado com mulher boa (emparelhamento atual)',
      insight_true: 'Sim',
      insight_false: 'Não',
      insight_pending: 'Execute até o fim para avaliar.',
      insight_termination_value: '{used} / {bound} propostas',
      insight_optimal_current: 'Vale para o emparelhamento calculado neste cenário um-para-um.',
      insight_optimal_current_many_to_one: 'Vale para o emparelhamento calculado neste cenário muitos-para-um.',
      insight_optimal_not_applicable: 'Avaliado em cenários um-para-um sem pares proibidos e no pareamento de residentes.',
      insight_good_bad_current: 'Vale para o emparelhamento calculado.',
      insight_good_bad_not_applicable: 'Categorias ausentes ou incompletas.',

      side_men: 'Homens',
      side_women: 'Mulheres',
      side_hospitals: 'Hospitais',
      side_residents: 'Residentes',
      partner_none: '-',
      code_comment_exhausted_all: 'propôs para todos',
      code_comment_exhausted_allowed: 'propôs para todos os receptores permitidos (não em F)',
      code_comment_prefs_exclude_f: 'p_prefs contém apenas pares (p, r) com (p, r) não em F',
      code_comment_engaged_one: 'receptor -> proponente',
      code_comment_engaged_many: 'receptor -> proponentes',
      code_comment_worst_current: 'pior proponente atual mantido pelo receptor',

      code_1: '1  from collections import deque',
      code_2: '2  w_rank = {w: {m: i for i, m in enumerate(pref)} for w, pref in w_prefs.items()}',
      code_3: '3  free_men = deque(m_prefs.keys())',
      code_4: '4  next_idx = {m: 0 for m in m_prefs}',
      code_5: '5  engaged_to = {}  # woman -> man',
      code_6: '6  while free_men:',
      code_7: '7      m = free_men.popleft()',
      code_8: '8      if next_idx[m] >= len(m_prefs[m]): continue  # propôs para todos',
      code_9: '9      w = m_prefs[m][next_idx[m]]',
      code_10: '10     next_idx[m] += 1',
      code_11: '11     if w not in engaged_to:',
      code_12: '12         engaged_to[w] = m',
      code_13: '13     else:',
      code_14: "14         m_prime = engaged_to[w]",
      code_15: '15         if w_rank[w][m_prime] < w_rank[w][m]: free_men.append(m)',
      code_16: '16         else:',
      code_17: '17             engaged_to[w] = m; free_men.append(m_prime)',
      code_18: '18 return {(m, w) for w, m in engaged_to.items()}',

      legend_rank: 'posição',
      legend_engaged: 'aresta noivada',
      legend_active: 'proposta atual',
      legend_regular: 'aresta de preferência',

      curve_progress: 'n={n} ({done}/{total})',
      curve_idle: 'Configure o intervalo e execute para gerar curvas.',
      curve_empty: 'Sem dados ainda.',

      category_good: 'bom',
      category_bad: 'ruim'
    }
  };

  function format(text, params) {
    return String(text).replace(/\{(\w+)\}/g, (_, key) => {
      if (params && Object.prototype.hasOwnProperty.call(params, key)) {
        return String(params[key]);
      }
      return `{${key}}`;
    });
  }

  window.GSI18N = {
    messages,
    t(lang, key, params = {}) {
      const dict = messages[lang] || messages.en;
      const fallback = messages.en[key] || key;
      const template = dict[key] || fallback;
      return format(template, params);
    }
  };
})();
